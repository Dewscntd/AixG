import { Injectable, Logger } from '@nestjs/common';\nimport { PrismaService } from '../../../prisma/prisma.service';\nimport { TeamAggregate } from '../../domain/entities/team.aggregate';\nimport { TeamId } from '../../domain/value-objects/team-id.vo';\n\nexport interface ITeamRepository {\n  save(team: TeamAggregate): Promise<void>;\n  findById(id: string): Promise<TeamAggregate | null>;\n  findByName(name: string): Promise<TeamAggregate | null>;\n  findAll(filters?: {\n    name?: string;\n    league?: string;\n    founded?: { from?: number; to?: number };\n    limit?: number;\n    offset?: number;\n  }): Promise<TeamAggregate[]>;\n  delete(id: string): Promise<void>;\n  exists(id: string): Promise<boolean>;\n}\n\n@Injectable()\nexport class TeamRepository implements ITeamRepository {\n  private readonly logger = new Logger(TeamRepository.name);\n\n  constructor(private readonly prisma: PrismaService) {}\n\n  async save(team: TeamAggregate): Promise<void> {\n    this.logger.log(`Saving team: ${team.id.value}`);\n\n    try {\n      const teamData = team.toPrimitives();\n      \n      await this.prisma.team.upsert({\n        where: { id: teamData.id },\n        update: {\n          name: teamData.name,\n          shortName: teamData.shortName,\n          logo: teamData.logo,\n          primaryColor: teamData.primaryColor,\n          secondaryColor: teamData.secondaryColor,\n          stadium: teamData.stadium,\n          foundedYear: teamData.foundedYear,\n          website: teamData.website,\n          socialMedia: teamData.socialMedia,\n          formation: teamData.formation,\n          updatedAt: teamData.updatedAt,\n        },\n        create: {\n          id: teamData.id,\n          name: teamData.name,\n          shortName: teamData.shortName,\n          logo: teamData.logo,\n          primaryColor: teamData.primaryColor,\n          secondaryColor: teamData.secondaryColor,\n          stadium: teamData.stadium,\n          foundedYear: teamData.foundedYear,\n          website: teamData.website,\n          socialMedia: teamData.socialMedia,\n          formation: teamData.formation,\n          createdAt: teamData.createdAt,\n          updatedAt: teamData.updatedAt,\n        },\n      });\n\n      this.logger.log(`Team saved successfully: ${team.id.value}`);\n    } catch (error) {\n      this.logger.error(`Failed to save team ${team.id.value}: ${error.message}`, error.stack);\n      throw error;\n    }\n  }\n\n  async findById(id: string): Promise<TeamAggregate | null> {\n    this.logger.log(`Finding team by ID: ${id}`);\n\n    try {\n      const teamData = await this.prisma.team.findUnique({\n        where: { id },\n        include: {\n          players: true,\n        },\n      });\n\n      if (!teamData) {\n        return null;\n      }\n\n      return TeamAggregate.fromPrimitives(teamData);\n    } catch (error) {\n      this.logger.error(`Failed to find team by ID ${id}: ${error.message}`, error.stack);\n      throw error;\n    }\n  }\n\n  async findByName(name: string): Promise<TeamAggregate | null> {\n    this.logger.log(`Finding team by name: ${name}`);\n\n    try {\n      const teamData = await this.prisma.team.findFirst({\n        where: { \n          name: {\n            equals: name,\n            mode: 'insensitive',\n          },\n        },\n        include: {\n          players: true,\n        },\n      });\n\n      if (!teamData) {\n        return null;\n      }\n\n      return TeamAggregate.fromPrimitives(teamData);\n    } catch (error) {\n      this.logger.error(`Failed to find team by name ${name}: ${error.message}`, error.stack);\n      throw error;\n    }\n  }\n\n  async findAll(filters?: {\n    name?: string;\n    league?: string;\n    founded?: { from?: number; to?: number };\n    limit?: number;\n    offset?: number;\n  }): Promise<TeamAggregate[]> {\n    this.logger.log('Finding all teams with filters:', filters);\n\n    try {\n      const where: any = {};\n\n      if (filters?.name) {\n        where.name = {\n          contains: filters.name,\n          mode: 'insensitive',\n        };\n      }\n\n      if (filters?.founded) {\n        where.foundedYear = {};\n        if (filters.founded.from) {\n          where.foundedYear.gte = filters.founded.from;\n        }\n        if (filters.founded.to) {\n          where.foundedYear.lte = filters.founded.to;\n        }\n      }\n\n      const teamsData = await this.prisma.team.findMany({\n        where,\n        include: {\n          players: true,\n        },\n        orderBy: { createdAt: 'desc' },\n        take: filters?.limit || 50,\n        skip: filters?.offset || 0,\n      });\n\n      return teamsData.map(teamData => TeamAggregate.fromPrimitives(teamData));\n    } catch (error) {\n      this.logger.error(`Failed to find teams: ${error.message}`, error.stack);\n      throw error;\n    }\n  }\n\n  async delete(id: string): Promise<void> {\n    this.logger.log(`Deleting team: ${id}`);\n\n    try {\n      await this.prisma.team.delete({\n        where: { id },\n      });\n\n      this.logger.log(`Team deleted successfully: ${id}`);\n    } catch (error) {\n      this.logger.error(`Failed to delete team ${id}: ${error.message}`, error.stack);\n      throw error;\n    }\n  }\n\n  async exists(id: string): Promise<boolean> {\n    try {\n      const count = await this.prisma.team.count({\n        where: { id },\n      });\n      return count > 0;\n    } catch (error) {\n      this.logger.error(`Failed to check if team exists ${id}: ${error.message}`, error.stack);\n      return false;\n    }\n  }\n}